// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.Coordinate;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.Timer;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.drive.MecanumDrive;
import edu.wpi.first.wpilibj.interfaces.Gyro;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


public class PropulsionSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX leftBackMtr;
    private WPI_TalonSRX rightBackMtr;
    private WPI_TalonSRX rightFrontMtr;
    private WPI_TalonSRX leftFrontMtr;

    private MecanumDrive mecanumDrive;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private Gyro gyro;

    private Timer timer;
    private Coordinate m_currentPos;
    private boolean m_isAiming = false;
    private double m_aimPower = 0.0;
    
    /**
     * Constructs a new PropulsionSys.
     * 
     * PropulsionSys contains all the motors of the drivebase and the gyro/IMU
     * 
     * This subsystem contains mecanum drive and tank drive methods for controlling the drivebase as well as getters to
     * get variables returned from the gyro/IMU and drive motor encoders.
     */
    public PropulsionSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        leftBackMtr = new WPI_TalonSRX(4);
        addChild("LeftBackMtr",leftBackMtr);
        leftBackMtr.setInverted(false);

        rightBackMtr = new WPI_TalonSRX(1);
        addChild("RightBackMtr",rightBackMtr);
        rightBackMtr.setInverted(true);

        rightFrontMtr = new WPI_TalonSRX(2);
        addChild("RightFrontMtr",rightFrontMtr);
        rightFrontMtr.setInverted(true);

        leftFrontMtr = new WPI_TalonSRX(3);
        addChild("LeftFrontMtr",leftFrontMtr);
        leftFrontMtr.setInverted(false);

        mecanumDrive = new MecanumDrive(leftFrontMtr, leftBackMtr, rightFrontMtr, rightBackMtr);
        addChild("MecanumDrive",mecanumDrive);
        mecanumDrive.setExpiration(0.1);
        mecanumDrive.setMaxOutput(1.0);
        mecanumDrive.setSafetyEnabled(true);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        gyro = new ADXRS450_Gyro();

        timer = new Timer();
        timer.start();

        m_currentPos = new Coordinate();
    }

    /**
     * Controls the drive base using mecanum drive with nonlinear inputs.
     * 
     * @param x strafe input
     * @param y drive input
     * @param z turn input
     * @param isFieldOriented if true, the robot will drive with respect to its initial heading
     */
    public void mecanumDriveControlNonlinear(double x, double y, double z, boolean isFieldOriented) {
        if(x < 0) {
            x *= -x;
        }
        else {
            x *= x;
        }

        if(y < 0) {
            y *= -y;
        }
        else {
            y *= y;
        }

        if(z < 0) {
            z *= -z;
        }
        else {
            z *= z;
        }

        if(isFieldOriented) {
            mecanumDrive.driveCartesian(y, x, z + m_aimPower);

        }
        else {
            mecanumDrive.driveCartesian(y, x, z + m_aimPower);
        }
    }

    /**
     * Controls the drive base using mecanum drive with nonlinear inputs.
     * 
     * @param x strafe input
     * @param y drive input
     * @param z turn input
     * @param zFine fine turn input
     * @param isFieldOriented if true, the robot will drive with respect to its initial heading
     */
    public void mecanumDriveControlNonlinear(double x, double y, double z, double zFine, boolean isFieldOriented) {
        SmartDashboard.putNumber("y mov", y);

        if(x < 0) {
            x *= -x;
        }
        else {
            x *= x;
        }

        if(y < 0) {
            y *= -y;
        }
        else {
            y *= y;
        }

        if(z < 0) {
            z *= -z;
        }
        else {
            z *= z;
        }

        if(!m_isAiming) {
            if(isFieldOriented) {
                mecanumDrive.driveCartesian(y, x, z + m_aimPower, gyro.getAngle());
            }
            else {
                mecanumDrive.driveCartesian(y, x, z + m_aimPower);
            }
        }
    }

    /**
     * Controls the drive base using mecanum drive.
     * 
     * @param x strafe input
     * @param y drive input
     * @param z turn input
     * @param zFine fine turn input
     * @param isFieldOriented if true, the robot will drive with respect to its initial heading
     */
    public void mecanumDriveControl(double x, double y, double z, boolean isFieldOriented) {
        if(!m_isAiming) {
            if(isFieldOriented) {
                mecanumDrive.driveCartesian(y, x, z, gyro.getAngle());

            }
            else {
                mecanumDrive.driveCartesian(y, x, z);
            }
        }
    }
    
    /**
     * Controls the drive base using mecanum drive.
     * 
     * @param x strafe input
     * @param y drive input
     * @param z turn input
     * @param zFine fine turn input
     * @param isFieldOriented if true, the robot will drive with respect to its initial heading
     */
    public void mecanumDriveControl(double x, double y, double z, double zFine, boolean isFieldOriented) {
        if(isFieldOriented) {
            mecanumDrive.driveCartesian(y, x, z + zFine * Constants.Joystick.fineTurnRatio, gyro.getAngle());

        }
        else {
            mecanumDrive.driveCartesian(y, x, z + zFine * Constants.Joystick.fineTurnRatio);
        }
    }

    /**
     * Controls the drive base using tank drive.
     * 
     * <p>This method of driving does not include strafing.
     * 
     * @param left power delivered to the left wheels
     * @param right power delivered to the right wheels
     */
    public void tankDriveControl(double left, double right) {
        leftFrontMtr.set(left);
        leftBackMtr.set(left);
        rightFrontMtr.set(right);
        rightBackMtr.set(right);
    }

    /**
     * Controls the drive base using tank drive with nonlinear inputs.
     * 
     * <p>This method of driving does not include strafing.
     * 
     * @param left power delivered to the left wheels
     * @param right power delivered to the right wheels
     */
    public void tankDriveControlNonlinear(double left, double right) {
        if(left < 0) {
            left *= -left;
        }
        else {
            left *= left;
        }

        if(right < 0) {
            right *= -right;
        }
        else {
            right *= right;
        }

        leftFrontMtr.set(left);
        leftBackMtr.set(left);
        rightFrontMtr.set(right);
        rightBackMtr.set(right);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

        // Calculating position every 100 milliseconds
        if(timer.hasElapsed(0.1)) {
            timer.reset();
            m_currentPos.setX(m_currentPos.getX() + (getAverageEncoderRate() / Constants.Encoder.countsPerInch * Math.cos(gyro.getAngle() / 57.2958) * 0.0833333));
            m_currentPos.setY(m_currentPos.getY() + (getAverageEncoderRate() / Constants.Encoder.countsPerInch * Math.sin(gyro.getAngle() / 57.2958) * 0.0833333));
        }

        SmartDashboard.putNumber("x", m_currentPos.getX());
        SmartDashboard.putNumber("y", m_currentPos.getY());

        SmartDashboard.putNumber("heading", gyro.getAngle());
        SmartDashboard.putNumber("angle rate", gyro.getRate());

        SmartDashboard.putNumber("average encoder counts", getAverageEncoderCounts());
        SmartDashboard.putNumber("feet per second", getFeetPerSecond());

        SmartDashboard.putNumber("front left pos", leftFrontMtr.getSelectedSensorPosition());
        SmartDashboard.putNumber("back left pos", leftBackMtr.getSelectedSensorPosition());
        SmartDashboard.putNumber("front right pos", rightFrontMtr.getSelectedSensorPosition());
        SmartDashboard.putNumber("back right pos", rightBackMtr.getSelectedSensorPosition());

        SmartDashboard.putBoolean("isAiming", m_isAiming);

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    /**
     * Returns the estimated coordinate position of the robot in feet.
     * 
     * <p>The coordinate point is calculated using the encoders for rate of change and the gyro/IMU for the angle.
     * 
     * @return the estimated position of the robot as a {@link frc.robot.Coordinate}
     */
    public Coordinate getCurrentPos() {
        return m_currentPos;
    }

    /**
     * Returns the average encoder counts of the drive base motors.
     * 
     * <p>The average encoder counts will increase when the robot drives forward and decrease when it
     * drives backward. It should stay roughly the same when the robot turns in place.
     * 
     * @return the average encoder counts from {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorPosition()
     */
    public double getAverageEncoderCounts() {
        return -(leftFrontMtr.getSelectedSensorPosition() + leftBackMtr.getSelectedSensorPosition() + 
        rightFrontMtr.getSelectedSensorPosition() + rightBackMtr.getSelectedSensorPosition()) * 0.25;
    }

    /**
     * Returns the estimated distance the robot has driven in feet.
     * 
     * <p>Distance will increase when the robot drives forward and decrease when it
     * drives backward. It should stay roughly the same when the robot turns in place.
     * 
     * @return the estimated distance the robot has traveled in feet from 
     * {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorPosition()
     */
    public double getDistance() {
        return -(leftFrontMtr.getSelectedSensorVelocity() + leftBackMtr.getSelectedSensorVelocity() + 
        rightFrontMtr.getSelectedSensorVelocity() + rightBackMtr.getSelectedSensorVelocity()) * 0.0208333 / Constants.Encoder.countsPerInch;
    }

    /**
     * Returns the rate of change of encoder counts in counts per 100 milliseconds.
     * 
     * <p>The average encoder rate will be positive when the robot drives forward and negative when it
     * drives backward.
     * 
     * @return the average encoder velocity from {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorVelocity()
     */
    public double getAverageEncoderRate() {
        return -(leftFrontMtr.getSelectedSensorVelocity() + leftBackMtr.getSelectedSensorVelocity() + 
        rightFrontMtr.getSelectedSensorVelocity() + rightBackMtr.getSelectedSensorVelocity()) * 0.25;
    }

    /**
     * Returns the estimated forward speed of the robot in feet per second based on the average encoder velocity 
     * from {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorVelocity().
     * 
     * <p>Feet per second will be positive when the robot drives forward and negative when it drives backward. 
     * 
     * @return the estimated feet per second of the forward movement of the robot
     */
    public double getFeetPerSecond() {
        return -(leftFrontMtr.getSelectedSensorVelocity() + leftBackMtr.getSelectedSensorVelocity() + 
        rightFrontMtr.getSelectedSensorVelocity() + rightBackMtr.getSelectedSensorVelocity()) * 2.5 / Constants.Encoder.countsPerFoot;
    }


    /**
     * Returns the estimated forward speed of the robot in inches per second based on the average encoder velocity 
     * from {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorVelocity().
     * 
     * <p>Inches per second will be positive when the robot drives forward and negative when it drives backward. 
     * 
     * @return the estimated inches per second of the forward movement of the robot
     */
    public double getInchesPerSecond() {
        return -(leftFrontMtr.getSelectedSensorVelocity() + leftBackMtr.getSelectedSensorVelocity() + 
        rightFrontMtr.getSelectedSensorVelocity() + rightBackMtr.getSelectedSensorVelocity()) * 2.5 / Constants.Encoder.countsPerInch;
    }

    
    /**
     * Returns the heading of the robot given by the gyro/IMU in degrees.
     * 
     * <p>The angle measurement given is continuous, meaning it will keep increasing beyond 360°.
     * 
     * <p>Angle increases as the robot turns clockwise and decreases as it turns counterclockwise.
     * 
     * @return the angle of the gyro in degrees from {@link edu.wpi.first.wpilibj.interfaces.Gyro}.getAngle()
     */
    public double getHeading() {
        return gyro.getAngle();
    }

    
    /** 
     * Returns the rate of rotation of the robot given by the gyro/IMU in degrees per second.
     * 
     * <p>Rate is positive as the robot turns clockwise and negative as it turns counterclockwise.
     * 
     * @return the rate of the gyro in degrees per second from {@link edu.wpi.first.wpilibj.interfaces.Gyro}.getRate()
     */
    public double getAngleRate() {
        return gyro.getRate();
    }

    /**
     * Sets all drive motor powers to zero with {@link edu.wpi.first.wpilibj.drive.DifferentialDrive}.stopMotor()
     */
    public void stop() {
        mecanumDrive.stopMotor();
    }

    public void setAimPower(double aimPower) {
        m_aimPower = aimPower;
    }
}

