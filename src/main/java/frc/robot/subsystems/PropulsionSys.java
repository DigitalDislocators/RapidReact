// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.Constants;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.math.kinematics.DifferentialDriveWheelSpeeds;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.drive.MecanumDrive;
import edu.wpi.first.wpilibj.interfaces.Gyro;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


public class PropulsionSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX leftBackMtr;
    private WPI_TalonSRX rightBackMtr;
    private WPI_TalonSRX rightFrontMtr;
    private WPI_TalonSRX leftFrontMtr;

    private MecanumDrive mecanumDrive;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private Gyro gyro;

    // Odometry class for tracking robot pose
    private final DifferentialDriveOdometry m_odometry;
    
    /**
     * Constructs a new PropulsionSys.
     * 
     * PropulsionSys contains all the motors of the drivebase and the gyro/IMU
     * 
     * This subsystem contains mecanum drive and tank drive methods for controlling the drivebase as well as getters to
     * get variables returned from the gyro/IMU and drive motor encoders.
     */
    public PropulsionSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        leftBackMtr = new WPI_TalonSRX(4);
        addChild("LeftBackMtr",leftBackMtr);
        leftBackMtr.setInverted(false);

        rightBackMtr = new WPI_TalonSRX(1);
        addChild("RightBackMtr",rightBackMtr);
        rightBackMtr.setInverted(true);

        rightFrontMtr = new WPI_TalonSRX(2);
        addChild("RightFrontMtr",rightFrontMtr);
        rightFrontMtr.setInverted(true);

        leftFrontMtr = new WPI_TalonSRX(3);
        addChild("LeftFrontMtr",leftFrontMtr);
        leftFrontMtr.setInverted(false);

        mecanumDrive = new MecanumDrive(leftFrontMtr, leftBackMtr, rightFrontMtr, rightBackMtr);
        addChild("MecanumDrive",mecanumDrive);
        mecanumDrive.setExpiration(0.1);
        mecanumDrive.setMaxOutput(1.0);
        mecanumDrive.setSafetyEnabled(true);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


        leftFrontMtr.configVelocityMeasurementWindow(4);
        leftBackMtr.configVelocityMeasurementWindow(4);
        rightFrontMtr.configVelocityMeasurementWindow(4);
        rightBackMtr.configVelocityMeasurementWindow(4);

        gyro = new ADXRS450_Gyro();

        m_odometry = new DifferentialDriveOdometry(gyro.getRotation2d(), new Pose2d(0, 0, new Rotation2d()));
    }

    /**
     * Controls the drive base using mecanum drive with nonlinear inputs.
     * 
     * @param x strafe input
     * @param y drive input
     * @param z turn input
     * @param isFieldOriented if true, the robot will drive with respect to its initial heading
     */
    public void mecanumDriveControlNonlinear(double x, double y, double z, boolean isFieldOriented) {
        if(x < 0) {
            x *= -x;
        }
        else {
            x *= x;
        }

        if(y < 0) {
            y *= -y;
        }
        else {
            y *= y;
        }

        if(z < 0) {
            z *= -z;
        }
        else {
            z *= z;
        }

        if(isFieldOriented) {
            mecanumDrive.driveCartesian(y, x, z);

        }
        else {
            mecanumDrive.driveCartesian(y, x, z);
        }
    }

    /**
     * Controls the drive base using mecanum drive with nonlinear inputs.
     * 
     * @param x strafe input
     * @param y drive input
     * @param z turn input
     * @param zFine fine turn input
     * @param isFieldOriented if true, the robot will drive with respect to its initial heading
     */
    public void mecanumDriveControlNonlinear(double x, double y, double z, double zFine, boolean isFieldOriented) {
        if(x < 0) {
            x *= -x;
        }
        else {
            x *= x;
        }

        if(y < 0) {
            y *= -y;
        }
        else {
            y *= y;
        }

        if(z < 0) {
            z *= -z;
        }
        else {
            z *= z;
        }

        if(isFieldOriented) {
            mecanumDrive.driveCartesian(y, x, z + + zFine * Constants.Joystick.fineTurnRatio, gyro.getAngle());
        }
        else {
            mecanumDrive.driveCartesian(y, x, z + zFine * Constants.Joystick.fineTurnRatio);
        }
    }

    /**
     * Controls the drive base using mecanum drive.
     * 
     * @param x strafe input
     * @param y drive input
     * @param z turn input
     * @param zFine fine turn input
     * @param isFieldOriented if true, the robot will drive with respect to its initial heading
     */
    public void mecanumDriveControl(double x, double y, double z, boolean isFieldOriented) {
        if(isFieldOriented) {
            mecanumDrive.driveCartesian(y, x, z, gyro.getAngle());

        }
        else {
            mecanumDrive.driveCartesian(y, x, z);
        }
    }
    
    /**
     * Controls the drive base using mecanum drive.
     * 
     * @param x strafe input
     * @param y drive input
     * @param z turn input
     * @param zFine fine turn input
     * @param isFieldOriented if true, the robot will drive with respect to its initial heading
     */
    public void mecanumDriveControl(double x, double y, double z, double zFine, boolean isFieldOriented) {
        if(isFieldOriented) {
            mecanumDrive.driveCartesian(y, x, z + zFine * Constants.Joystick.fineTurnRatio, gyro.getAngle());

        }
        else {
            mecanumDrive.driveCartesian(y, x, z + zFine * Constants.Joystick.fineTurnRatio);
        }
    }

    /**
     * Controls the drive base using tank drive.
     * 
     * <p>This method of driving does not include strafing.
     * 
     * @param left power delivered to the left wheels
     * @param right power delivered to the right wheels
     */
    public void tankDriveControl(double left, double right) {
        leftFrontMtr.set(left);
        leftBackMtr.set(left);
        rightFrontMtr.set(right);
        rightBackMtr.set(right);
    }

    /**
     * Controls the drive base using tank drive with nonlinear inputs.
     * 
     * <p>This method of driving does not include strafing.
     * 
     * @param left power delivered to the left wheels
     * @param right power delivered to the right wheels
     */
    public void tankDriveControlNonlinear(double left, double right) {
        if(left < 0) {
            left *= -left;
        }
        else {
            left *= left;
        }

        if(right < 0) {
            right *= -right;
        }
        else {
            right *= right;
        }

        leftFrontMtr.set(left);
        leftBackMtr.set(left);
        rightFrontMtr.set(right);
        rightBackMtr.set(right);
    }

    /**
     * The control method for trajectories.
     * 
     * <p>This method of driving does not include strafing.
     * 
     * @param left voltage delivered to the left wheels
     * @param right voltage delivered to the right wheels
     */
    public void tankDriveVolts(double leftVolts, double rightVolts) {
        leftFrontMtr.setVoltage(leftVolts);
        leftBackMtr.setVoltage(leftVolts);
        rightFrontMtr.setVoltage(rightVolts);
        rightBackMtr.setVoltage(rightVolts);
        mecanumDrive.feed();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

        // m_odometry.update(Rotation2d.fromDegrees(getHeading()), 
        //     (leftFrontMtr.getSelectedSensorPosition() + leftBackMtr.getSelectedSensorPosition()) * -0.5 / Constants.Encoder.countsPerMeter,
        //     (rightFrontMtr.getSelectedSensorPosition() + rightBackMtr.getSelectedSensorPosition()) * -0.5 / Constants.Encoder.countsPerMeter
        // );

        SmartDashboard.putNumber("heading", gyro.getAngle());
        SmartDashboard.putNumber("degrees per second", gyro.getRate());

        SmartDashboard.putNumber("miles per hour", getMilesPerHour());
        SmartDashboard.putNumber("feet per second", getFeetPerSecond());

        // SmartDashboard.putNumber("leftFront", leftFrontMtr.getSelectedSensorPosition());
        // SmartDashboard.putNumber("rightFront", rightFrontMtr.getSelectedSensorPosition());
        // SmartDashboard.putNumber("leftBack", leftBackMtr.getSelectedSensorPosition());
        // SmartDashboard.putNumber("rightBack", rightBackMtr.getSelectedSensorPosition());

        // SmartDashboard.putString("pose", getPose().getX() + ", " + getPose().getY());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    /**
     * Returns the currently-estimated pose of the robot.
     *
     * @return The pose.
     */
    public Pose2d getPose() {
        return m_odometry.getPoseMeters();
    }

    /**
     * Resets the odometry to the specified pose.
     *
     * @param pose The pose to which to set the odometry.
     */
    public void resetOdometry(Pose2d pose) {
        zero();
        m_odometry.resetPosition(pose, gyro.getRotation2d());
    }

    /**
     * Returns the current wheel speeds of the robot.
     *
     * @return The current wheel speeds.
     */
    public DifferentialDriveWheelSpeeds getDifferentialWheelSpeeds() {
        return new DifferentialDriveWheelSpeeds(
            (leftFrontMtr.getSelectedSensorVelocity() + rightFrontMtr.getSelectedSensorVelocity()) * 0.005,
            (leftBackMtr.getSelectedSensorVelocity() + rightBackMtr.getSelectedSensorVelocity()) * 0.005
        );
    }

    /**
     * Returns the average encoder counts of the drive base motors.
     * 
     * <p>The average encoder counts will increase when the robot drives forward and decrease when it
     * drives backward. It should stay roughly the same when the robot turns in place.
     * 
     * @return the average encoder counts from {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorPosition()
     */
    public double getAverageEncoderCounts() {
        return (leftFrontMtr.getSelectedSensorPosition() + leftBackMtr.getSelectedSensorPosition() + 
        rightFrontMtr.getSelectedSensorPosition() + rightBackMtr.getSelectedSensorPosition()) * -0.25;
    }

    

    /**
     * Returns the estimated distance the robot has driven in feet.
     * 
     * <p>Distance will increase when the robot drives forward and decrease when it
     * drives backward. It should stay roughly the same when the robot turns in place.
     * 
     * @return the estimated distance the robot has traveled in feet from 
     * {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorPosition()
     */
    public double getAverageEncoderDistance() {
        return (leftFrontMtr.getSelectedSensorVelocity() + leftBackMtr.getSelectedSensorVelocity() + 
        rightFrontMtr.getSelectedSensorVelocity() + rightBackMtr.getSelectedSensorVelocity()) * 0.25 / Constants.Encoder.countsPerFoot;
    }

    /**
     * Returns the rate of change of encoder counts in counts per 100 milliseconds.
     * 
     * <p>The average encoder rate will be positive when the robot drives forward and negative when it
     * drives backward.
     * 
     * @return the average encoder velocity from {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorVelocity()
     */
    public double getAverageEncoderRate() {
        return (leftFrontMtr.getSelectedSensorVelocity() + leftBackMtr.getSelectedSensorVelocity() + 
        rightFrontMtr.getSelectedSensorVelocity() + rightBackMtr.getSelectedSensorVelocity()) * 0.25;
    }

    /**
     * Returns the estimated forward speed of the robot in feet per second based on the average encoder velocity 
     * from {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorVelocity().
     * 
     * <p>Feet per second will be positive when the robot drives forward and negative when it drives backward. 
     * 
     * @return the estimated feet per second of the forward movement of the robot
     */
    public double getFeetPerSecond() {
        return -(leftFrontMtr.getSelectedSensorVelocity() + leftBackMtr.getSelectedSensorVelocity() + 
        rightFrontMtr.getSelectedSensorVelocity() + rightBackMtr.getSelectedSensorVelocity()) * 2.5 / Constants.Encoder.countsPerFoot;
    }

    /**
     * Returns the estimated forward speed of the robot in miles per hour based on the average encoder velocity 
     * from {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorVelocity().
     * 
     * <p>Miles per hour will be positive when the robot drives forward and negative when it drives backward. 
     * 
     * @return the estimated miles per hour of the forward movement of the robot
     */
    public double getMilesPerHour() {
        return getFeetPerSecond() * 0.681818;
    }

    /**
     * Returns the estimated forward speed of the robot in inches per second based on the average encoder velocity 
     * from {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.getSelectedSensorVelocity().
     * 
     * <p>Inches per second will be positive when the robot drives forward and negative when it drives backward. 
     * 
     * @return the estimated inches per second of the forward movement of the robot
     */
    public double getInchesPerSecond() {
        return -(leftFrontMtr.getSelectedSensorVelocity() + leftBackMtr.getSelectedSensorVelocity() + 
        rightFrontMtr.getSelectedSensorVelocity() + rightBackMtr.getSelectedSensorVelocity()) * 2.5 / Constants.Encoder.countsPerInch;
    }

    
    /**
     * Returns the heading of the robot given by the gyro/IMU in degrees.
     * 
     * <p>The angle measurement given is continuous, meaning it will keep increasing beyond 360°.
     * 
     * <p>Angle increases as the robot turns clockwise and decreases as it turns counterclockwise.
     * 
     * @return the angle of the gyro in degrees from {@link edu.wpi.first.wpilibj.interfaces.Gyro}.getAngle()
     */
    public double getHeading() {
        return gyro.getAngle();
    }

    
    /** 
     * Returns the rate of rotation of the robot given by the gyro/IMU in degrees per second.
     * 
     * <p>Rate is positive as the robot turns clockwise and negative as it turns counterclockwise.
     * 
     * @return the rate of the gyro in degrees per second from {@link edu.wpi.first.wpilibj.interfaces.Gyro}.getRate()
     */
    public double getAngleRate() {
        return -gyro.getRate();
    }

    /**
     * Sets all drive motor powers to zero with {@link edu.wpi.first.wpilibj.drive.DifferentialDrive}.stopMotor()
     */
    public void stop() {
        mecanumDrive.stopMotor();
    }

    /**
     * Sets the heading and all of the encoders to zero with {@link edu.wpi.first.wpilibj.interfaces.Gyro}.reset() and
     * {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.setSelectedSensorPosition(0.0)
     */
    public void zero() {
        gyro.reset();
        leftFrontMtr.setSelectedSensorPosition(0);
        leftBackMtr.setSelectedSensorPosition(0);
        rightFrontMtr.setSelectedSensorPosition(0);
        rightBackMtr.setSelectedSensorPosition(0);

    }

    public void zeroEncoders() {
        leftFrontMtr.setSelectedSensorPosition(0);
        leftBackMtr.setSelectedSensorPosition(0);
        rightFrontMtr.setSelectedSensorPosition(0);
        rightBackMtr.setSelectedSensorPosition(0);

    }

    public void setMaxOutput(double maxOutput) {
        mecanumDrive.setMaxOutput(maxOutput);
    }
}

