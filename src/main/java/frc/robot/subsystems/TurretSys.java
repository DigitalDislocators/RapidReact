// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import java.util.Map;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.GenericHID.RumbleType;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.RobotContainer;
import oi.limelightvision.limelight.frc.Limelight;
import oi.limelightvision.limelight.frc.ControlMode.LedMode;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class TurretSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private IndexerSys m_indexerSys;
    private ShooterSys m_shooterSys;

    private PIDController m_pidController;

    private Limelight limelight;
    private WPI_TalonSRX turretMtr;

    private boolean m_trackingEnabled;
    private double m_angle;
    private double m_controlAngle;
    private boolean m_isManualControl;
    private boolean m_isHolding;
    private boolean m_isClimbing;

    private Timer rumbleTimer;
    private boolean prevIsTargetFound;

    private NetworkTableEntry sb_turretAngle;
    private NetworkTableEntry sb_isTracking;
    private NetworkTableEntry sb_trackingEnabled;
    private NetworkTableEntry sb_isHolding;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
     * Constructs a new ShooterSys.
     * 
     * TurretSys contains the turret motor and the limelight.
     * 
     * This subsystem contains methods for accessing and controlling the turret and limelight.
     */
    public TurretSys(IndexerSys indexerSys, ShooterSys shooterSys) {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        limelight = new Limelight();

        limelight.getStream();

        turretMtr = new WPI_TalonSRX(7);
        turretMtr.setSelectedSensorPosition(0);
        turretMtr.configNeutralDeadband(0.0);
        turretMtr.setInverted(true);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_indexerSys = indexerSys;
        m_shooterSys = shooterSys;

        m_pidController = new PIDController(Constants.PID.turretP, Constants.PID.turretI, Constants.PID.turretD);

        m_trackingEnabled = true;
        m_angle = 0;
        m_controlAngle = 0;

        rumbleTimer = new Timer();
        prevIsTargetFound = false;

        sb_turretAngle = Shuffleboard.getTab("DOOFENSHMIRTZ").add("Turret Angle", 0)
            .withWidget(BuiltInWidgets.kNumberBar)
            .withProperties(Map.of("Min", -180, "Max", 180))
            .withSize(5, 2)
            .withPosition(9, 5)
            .getEntry();
        sb_isTracking = Shuffleboard.getTab("DOOFENSHMIRTZ").add("Target Locked", false)
            .withWidget(BuiltInWidgets.kBooleanBox)
            .withSize(3, 2)
            .withPosition(14, 3)
            .getEntry();
        sb_trackingEnabled = Shuffleboard.getTab("DOOFENSHMIRTZ").add("Tracking Enabled", false)
            .withWidget(BuiltInWidgets.kBooleanBox)
            .withSize(3, 2)
            .withPosition(17, 3)
            .getEntry();
        sb_isHolding = Shuffleboard.getTab("DOOFENSHMIRTZ").add("Holding Angle", false)
            .withWidget(BuiltInWidgets.kBooleanBox)
            .withSize(2, 2)
            .withPosition(7, 5)
            .getEntry();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        
        // Getting current turret angle from encoder counts
        m_angle = turretMtr.getSelectedSensorPosition() / Constants.Encoder.countsPerDegree;
        
        sb_turretAngle.setDouble(m_angle);
        sb_isTracking.setBoolean(isTargetFound() && m_trackingEnabled  && !m_isManualControl);
        sb_trackingEnabled.setBoolean(m_trackingEnabled);
        sb_isHolding.setBoolean(m_isHolding);

        // Turret control logic will only run if in teleOp
        // Angle is set in auto with AutoSetTurretAngleCmd, which runs the setAngle methods
        if(DriverStation.isAutonomous()) {
            // Turret will only track if allowed
            // Otherwise it will run the turret to the desired angle
            setLED(true);
            if(m_trackingEnabled && isTargetFound()) {
                track();
            }
            else {
                setAngle(m_controlAngle, Constants.Power.maxTurretPower);
            }
        }
        else {
            // Manual control overrides all other forms of control
            if(m_isManualControl) {
                setLED(true);
                // Makes sure manual control does not exceed bounds
                if(m_controlAngle > Constants.Encoder.turretWindow) {
                    m_controlAngle = Constants.Encoder.turretWindow;
                }
                else if(m_controlAngle < -Constants.Encoder.turretWindow) {
                    m_controlAngle = -Constants.Encoder.turretWindow;
                }
                setAngle(m_controlAngle, Constants.Power.maxTurretPower);
            }
            // Turret will hold position when joystick is released
            else if(m_isHolding || m_isClimbing) {
                setLED(!m_isClimbing);
                // Turret holds control angle
                setAngle(m_controlAngle, Constants.Power.maxTurretPower);
                // Disables holding if target is found
                if(isTargetFound() && !m_isClimbing) {
                    m_isHolding = false;
                }
            }
            else {
                m_controlAngle = m_angle;
                // Turret can only track if tracking is enabled
                if(!m_trackingEnabled) {
                    setLED(false);
                    turretMtr.stopMotor();
                }
                else {
                    // If turret is out of range, it can only track if a target will bring it back into range
                    if(m_angle < -Constants.Encoder.turretWindow && isTargetFound()) {
                        if(getX() > 0) {
                            track();
                        }
                        else {
                            turretMtr.stopMotor();
                        }
                    }
                    else if(m_angle > Constants.Encoder.turretWindow && isTargetFound()) {
                        if(getX() < 0) {
                            track();
                        }
                        else {
                            turretMtr.stopMotor();
                        }
                    }
                    else {
                        // Tracking only starts if cargo is in front of the sensor
                        // If no target is found or no cargo is in front of the sensor, set the turret angle to zero
                        if(m_indexerSys.cargoIsIn() || m_shooterSys.get() > Constants.Power.lowGoal) {
                            setLED(true);
                            if(isTargetFound()) {
                                track();
                            }
                            else {
                                setAngle(0, Constants.Power.maxTurretPower);
                            }
                        }
                        else {
                            setLED(false);
                            setAngle(0, Constants.Power.maxTurretPower);
                        }
                    }
                }
            }
        }

        // If turret locks on or loses a target, buzz the controller
        if(prevIsTargetFound != isTargetFound() && rumbleTimer.get() == 0) {
                rumbleTimer.start();
        }

        if(rumbleTimer.get() > 0 && rumbleTimer.get() < Constants.Rumble.buzzTime) {
            // Controller will buzz if rumbleTimer starts and is less than the set time
            RobotContainer.getInstance().setRumble(RumbleType.kRightRumble, 1.0);
        }
        else if(!m_trackingEnabled) {
            // Light buzz to notify drivers that tracking is disabled
            rumbleTimer.stop();
            rumbleTimer.reset();
            RobotContainer.getInstance().setRumble(RumbleType.kRightRumble, 0.33);
        }
        else {
            // Reset rumbleTimer for next time tracking status changes
            rumbleTimer.stop();
            rumbleTimer.reset();
            RobotContainer.getInstance().setRumble(RumbleType.kRightRumble, 0.0);
        }

        prevIsTargetFound = isTargetFound();
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    public void track() {
        turretMtr.set(m_pidController.calculate(limelight.getdegRotationToTarget(), 0.0));
    }

    public void autoSetAngle(double angle) {
        m_controlAngle = angle;
    }

    public void setAngle(double target, double maxPower) {
        maxPower = Math.abs(maxPower);
        // double power = ((m_angle - target) * Constants.PID.turretP);
        double power = -m_pidController.calculate(m_angle, target);
        if(power > maxPower) {
            power = maxPower;
        }
        else if(power < -maxPower) {
            power = -maxPower;
        }

        turretMtr.set(power);
    }

    public void joystickPOVControl(double x, double y) {
        double distance = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        if(distance < 0.25 && !m_isClimbing) {
            m_isManualControl = false;
        }
        else {
            m_isManualControl = true;
            double angle = Math.toDegrees(Math.atan2(x, y));
            if(angle > Constants.Encoder.turretWindow) {
                angle -= 360;
            }
            m_controlAngle = angle;
        }
    }

    public void joystickRotControl(double x) {
        if(Math.abs(x) > 0.15) {
            m_isManualControl = true;
            x *= x < 0 ? -x : x;
            m_controlAngle += x * Constants.Power.turretRotControl;
        }
        else {
            if(m_isManualControl) {
                m_isHolding = true;
            }
            if(!m_isClimbing) {
                m_isManualControl = false;
            }
        }
    }

    public void dPadPOVControl(double pov) {
        if(pov == -1 && !m_isClimbing) {
            m_isManualControl = false;
        }
        else {
            m_isManualControl = true;
            if(pov > Constants.Encoder.turretWindow) {
                pov -= 360;
            }
            else if(pov == Constants.Encoder.turretWindow) {
                if(m_angle > 0) {
                    pov = -Constants.Encoder.turretWindow;
                }
            }
            m_controlAngle = -pov;
        }
    }

    public void climb(boolean climb) {
        if(climb) {
            m_isClimbing = true;
            m_isHolding = true;
            m_trackingEnabled = false;
            m_controlAngle = -90;
        }
        else {
            m_isClimbing = false;
        }
    }

    public void highGoalPower() {
        if(isTargetFound()) {
            m_shooterSys.set(Math.max(Math.min((58 * Math.pow(getY(), 2) - 2133.9 * getY() + 8732.1) * 0.0001, 1.0), 0.72));
        }
        else {
            m_shooterSys.set(Constants.Power.launchpad);
        }
    }

    public boolean isClimbing() {
        return m_isClimbing;
    }

    public boolean trackingEnabled() {
        return m_trackingEnabled;
    }
    public void setTrackingEnabled(boolean trackingEnabled) {
        m_trackingEnabled = trackingEnabled;
    }

    public boolean isHolding() {
        return m_isHolding;
    }
    public void setIsHolding(boolean isHolding) {
        m_isHolding = isHolding;
    }

    public void setLED(boolean on) {
        if(!on || DriverStation.isDisabled()) {
            limelight.setLEDMode(LedMode.kforceOff);
        }
        else {
            limelight.setLEDMode(LedMode.kforceOn);
        }
    }

    public void zero() {
        turretMtr.setSelectedSensorPosition(0);
        m_controlAngle = 0;
    }

    public double getAngle() {
        return m_angle;
    }

    public boolean isTargetFound() {
        return limelight.getIsTargetFound();
    }

    public double getX() {
        return limelight.getdegRotationToTarget();
    }

    public double getY() {
        return limelight.getdegVerticalToTarget();
    }

    public double getTurnSpeed() {
        return turretMtr.getSelectedSensorVelocity();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
}