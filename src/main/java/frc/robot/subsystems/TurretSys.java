// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import oi.limelightvision.limelight.frc.Limelight;
import oi.limelightvision.limelight.frc.ControlMode.LedMode;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class TurretSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private IndexerSys m_indexerSys;
    private ShooterSys m_shooterSys;

    private PIDController m_pidController;

    private Limelight limelight;
    private WPI_TalonSRX turretMtr;

    private boolean m_trackingEnabled;
    private double m_angle;
    private double m_controlAngle;
    private boolean m_isManualControl;

    private Timer rumbleTimer;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
     * Constructs a new ShooterSys.
     * 
     * TurretSys contains the turret motor and the limelight.
     * 
     * This subsystem contains methods for accessing and controlling the turret and limelight.
     */
    public TurretSys(IndexerSys indexerSys, ShooterSys shooterSys) {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        limelight = new Limelight();

        limelight.getStream();

        turretMtr = new WPI_TalonSRX(7);
        turretMtr.setSelectedSensorPosition(0);
        turretMtr.configNeutralDeadband(0.0);
        turretMtr.setInverted(true);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_indexerSys = indexerSys;
        m_shooterSys = shooterSys;

        m_pidController = new PIDController(Constants.PID.turretP, Constants.PID.turretI, Constants.PID.turretD);

        m_trackingEnabled = true;
        m_angle = 0;

        rumbleTimer = new Timer();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        
        // Getting current turret angle from encoder counts
        m_angle = turretMtr.getSelectedSensorPosition() / Constants.Encoder.countsPerDegree;

        // The turret is controlled in autonomous by AutoSetTurretAngleCmd, which runs setAngle(target, maxPower)
        if(!DriverStation.isAutonomous()) {
            // Manual control overrides all other forms of control
            if(m_isManualControl) {
                setLED(true);
                setAngle(m_controlAngle, Constants.Power.maxTurretPower);
            }
            else {
                // Turret can only track if tracking is enabled
                if(!m_trackingEnabled) {
                    setLED(false);
                    turretMtr.stopMotor();
                }
                else {
                    // If turret is out of range, it can only track if a target will bring it back into range
                    if(m_angle < -Constants.Encoder.turretWindow && isTargetFound()) {
                        if(getX() > 0) {
                            track();
                        }
                        else {
                            turretMtr.stopMotor();
                        }
                    }
                    else if(m_angle > Constants.Encoder.turretWindow && isTargetFound()) {
                        if(getX() < 0) {
                            track();
                        }
                        else {
                            turretMtr.stopMotor();
                        }
                    }
                    else {
                        // Tracking only starts if cargo is in front of the sensor
                        // If no target is found or no cargo is in front of the sensor, set the turret angle to zero
                        if(m_indexerSys.cargoIsIn() || m_shooterSys.get() > Constants.Power.lowGoal) {
                            setLED(true);
                            if(isTargetFound()) {
                                track();
                            }
                            else {
                                setAngle(0, Constants.Power.maxTurretPower);
                            }
                        }
                        else {
                            setLED(false);
                            setAngle(0, Constants.Power.maxTurretPower);
                        }
                    }
                }
            }
        }

        SmartDashboard.putNumber("turret angle", m_angle);
        // SmartDashboard.putNumber("turret counts", turretMtr.getSelectedSensorPosition());
        // SmartDashboard.putNumber("limelight x", limelight.getdegRotationToTarget());
        // SmartDashboard.putNumber("limelight y", limelight.getdegVerticalToTarget());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    public void track() {
        turretMtr.set(m_pidController.calculate(limelight.getdegRotationToTarget(), 0.0));
    }

    public void setAngle(double target, double maxPower) {
        maxPower = Math.abs(maxPower);
        // double power = ((m_angle - target) * Constants.PID.turretP);
        double power = -m_pidController.calculate(m_angle, target);
        if(power > maxPower) {
            power = maxPower;
        }
        else if(power < -maxPower) {
            power = -maxPower;
        }

        turretMtr.set(power);
    }

    public void joystickControl(double x, double y) {
        double distance = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        if(distance < 0.25) {
            m_isManualControl = false;
        }
        else {
            m_isManualControl = true;
            double angle = Math.toDegrees(Math.atan2(x, y));
            if(angle > Constants.Encoder.turretWindow) {
                angle -= 360;
            }
            m_controlAngle = angle;
        }
    }

    public void dPadControl(double pov) {
        if(pov == -1) {
            m_isManualControl = false;
        }
        else {
            m_isManualControl = true;
            if(pov > Constants.Encoder.turretWindow) {
                pov -= 360;
            }
            else if(pov == Constants.Encoder.turretWindow) {
                if(m_angle > 0) {
                    pov = -Constants.Encoder.turretWindow;
                }
            }
            m_controlAngle = -pov;
        }
    }

    public void highGoalPower() {
        if(isTargetFound()) {
            m_shooterSys.set(Math.max(Math.min((58 * Math.pow(getY(), 2) - 2133.9 * getY() + 8732.1) * 0.0001, 1.0), 0.72));
            SmartDashboard.putString("Status", "HIGH GOAL SHOOT: " + m_shooterSys.get());
        }
        else {
            m_shooterSys.set(Constants.Power.launchpad);
        }
    }

    public boolean trackingEnabled() {
        return m_trackingEnabled;
    }
    public void setTrackingEnabled(boolean trackingEnabled) {
        m_trackingEnabled = trackingEnabled;
    }

    public void setLED(boolean on) {
        if(!on || DriverStation.isDisabled()) {
            limelight.setLEDMode(LedMode.kforceOff);
        }
        else {
            limelight.setLEDMode(LedMode.kforceOn);
        }
    }

    public void zero() {
        turretMtr.setSelectedSensorPosition(0);
    }

    public double getAngle() {
        return m_angle;
    }

    public boolean isTargetFound() {
        return limelight.getIsTargetFound();
    }

    public double getX() {
        return limelight.getdegRotationToTarget();
    }

    public double getY() {
        return limelight.getdegVerticalToTarget();
    }

    public double getTurnSpeed() {
        return turretMtr.getSelectedSensorVelocity();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
}