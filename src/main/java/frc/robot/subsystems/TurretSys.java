// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.GenericHID.RumbleType;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.RobotContainer;
import oi.limelightvision.limelight.frc.Limelight;
import oi.limelightvision.limelight.frc.ControlMode.LedMode;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class TurretSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private IndexerSys m_indexerSys;
    private ShooterSys m_shooterSys;

    private Limelight limelight;
    private WPI_TalonSRX turretMtr;

    private boolean m_isInverting;
    private boolean m_trackingEnabled;
    private boolean m_isTracking;
    private double m_angle;
    private double m_targetAngle;

    private Timer rumbleTimer;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
     * Constructs a new ShooterSys.
     * 
     * TurretSys contains the turret motor and the limelight.
     * 
     * This subsystem contains methods for accessing and controlling the turret and limelight.
     */
    public TurretSys(IndexerSys indexerSys, ShooterSys shooterSys) {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        limelight = new Limelight();

        limelight.getStream();

        turretMtr = new WPI_TalonSRX(7);
        turretMtr.setSelectedSensorPosition(0);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_indexerSys = indexerSys;
        m_shooterSys = shooterSys;

        m_isTracking = true;
        m_trackingEnabled = true;
        m_isInverting = false;
        m_angle = 0;
        m_targetAngle = 0;

        rumbleTimer = new Timer();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        
        m_angle = turretMtr.getSelectedSensorPosition() / Constants.Encoder.countsPerDegree;

        if(m_angle > Constants.Encoder.turretWindow) {
            if(limelight.getdegRotationToTarget() < -5) {
                m_isInverting = true;
                setAngle(-Constants.Encoder.turretWindow, false);
            }
            else if(limelight.getdegRotationToTarget() < 0 && !m_isInverting) {
                setAngle(Constants.Encoder.turretWindow, true);
            }
            else {
                track();
            }
        }
        else if(m_angle < -Constants.Encoder.turretWindow) {
            if(limelight.getdegRotationToTarget() > 5) {
                m_isInverting = true;
                setAngle(Constants.Encoder.turretWindow, false);
            }
            else if(limelight.getdegRotationToTarget() > 0 && !m_isInverting) {
                setAngle(-Constants.Encoder.turretWindow, true);
            }
            else {
                track();
            }
        }
        else {
            track();
        }

        if(m_shooterSys.get() != 0 && m_trackingEnabled) {
            setLED(true);
            m_isTracking = true;
        }
        else if(!m_isTracking || !m_indexerSys.cargoIsIn() || DriverStation.isDisabled()) {
            setLED(false);
            m_isTracking = false;
            setAngle(0, false);
        }
        else {
            setLED(true);
        }

        if(m_isTracking && !limelight.getIsTargetFound() && m_indexerSys.cargoIsIn()) {
            if(rumbleTimer.get() == 0) {
                rumbleTimer.start();
                RobotContainer.getInstance().setRumble(RumbleType.kRightRumble, 1.0);
            }
        }
        else {
            rumbleTimer.reset();
        }

        if(!m_indexerSys.cargoIsGood()) {
            RobotContainer.getInstance().setRumble(RumbleType.kLeftRumble, 1.0);
        }
        else {
            RobotContainer.getInstance().setRumble(RumbleType.kLeftRumble, 0.0);
        }

        if(m_isInverting) {
            setAngle(m_targetAngle, false);
        }

        if(rumbleTimer.hasElapsed(0.25) || limelight.getIsTargetFound()) {
            rumbleTimer.stop();
            RobotContainer.getInstance().setRumble(RumbleType.kRightRumble, 0.0);
        }

        SmartDashboard.putNumber("turret angle", m_angle);
        SmartDashboard.putNumber("turret counts", turretMtr.getSelectedSensorPosition());
        SmartDashboard.putNumber("limelight x", limelight.getdegRotationToTarget());
        SmartDashboard.putNumber("limelight y", limelight.getdegVerticalToTarget());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    public void track() {
        if(m_trackingEnabled && m_isTracking && (m_indexerSys.cargoIsIn() || m_shooterSys.get() != 0) && !m_isInverting) {
            turretMtr.set(limelight.getdegRotationToTarget() * Constants.KP.turret);
        }
    }

    public void setAngle(double target, boolean isTracking) {
        m_targetAngle = target;
        m_isTracking = isTracking;
        if(isTracking && limelight.getIsTargetFound()) {
            m_isTracking = true;
        }
        if(!m_isTracking) {
            if(limelight.getIsTargetFound()) {
                m_isTracking = true;
            }
            double power = ((m_angle - target) * Constants.KP.turret);
            // if(power > 0.75) {
            //     power = 0.75;
            // }
            // else if(power < -0.75) {
            //     power = -0.75;
            // }
            if(m_angle < target + 180 && m_angle > target - 180) {
                power *= 0.5;
            }

            turretMtr.set(power);
        }
        if(m_angle < target + 90 && m_angle > target - 90) {
            m_isTracking = true;
            m_isInverting = false;
        }
    }

    public void control(double target, double maxPower) {
        maxPower = Math.abs(maxPower);
        m_isTracking = false;
        double power = ((m_angle - target) * Constants.KP.turret);
        if(power > maxPower) {
            power = maxPower;
        }
        else if(power < -maxPower) {
            power = -maxPower;
        }
        turretMtr.set(power);
    }

    public void joystickControl(double x, double y) {
        double distance = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        if(distance < 0.25) {
            if(!m_trackingEnabled) {
                turretMtr.stopMotor();
            }
            else if(m_angle < Constants.Encoder.turretWindow && m_angle > -Constants.Encoder.turretWindow) {
                m_isTracking = true;
            }
        }
        else {
            double angle = Math.toDegrees(Math.atan2(x, y));
            if(angle > Constants.Encoder.turretWindow) {
                angle -= 360;
            }
            control(-angle, distance);
        }
    }

    public void dPadControl(double pov) {
        if(pov == -1) {
            if(!m_isTracking) {
                if(!m_trackingEnabled) {
                    turretMtr.stopMotor();
                }
                else if(m_angle < Constants.Encoder.turretWindow && m_angle > -Constants.Encoder.turretWindow) {
                    m_isTracking = true;
                }
            }
        }
        else {
            if(pov > Constants.Encoder.turretWindow) {
                pov -= 360;
            }
            else if(pov == Constants.Encoder.turretWindow) {
                if(m_angle > 0) {
                    pov = -Constants.Encoder.turretWindow;
                }
            }
            control(-pov, 1.0);
        }
    }

    public void highGoalPower() {
        double x = limelight.getdegVerticalToTarget();
        m_shooterSys.set(((-1.3 * Math.pow(x, 4) + 26.8 * Math.pow(x, 3) - 9.6 + Math.pow(x, 2) - 2607.1 * x + 91348) * 0.00001));
        SmartDashboard.putString("Status", "HIGH GOAL SHOOT: " + m_shooterSys.get());
    }

    public boolean trackingEnabled() {
        return m_trackingEnabled;
    }
    public void setTrackingEnabled(boolean trackingEnabled) {
        m_trackingEnabled = trackingEnabled;
    }

    public void setLED(boolean on) {
        if(!on) {
            limelight.setLEDMode(LedMode.kforceOff);
        }
        else {
            limelight.setLEDMode(LedMode.kforceOn);
        }
    }

    public void zero() {
        turretMtr.setSelectedSensorPosition(0);
    }

    public boolean isTargetFound() {
        return limelight.getIsTargetFound();
    }

    public double getX() {
        return limelight.getdegRotationToTarget();
    }

    public double getY() {
        return limelight.getdegVerticalToTarget();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
}

