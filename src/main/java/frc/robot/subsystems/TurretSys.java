// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import oi.limelightvision.limelight.frc.Limelight;
import oi.limelightvision.limelight.frc.ControlMode.LedMode;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class TurretSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private Limelight limelight;
    private WPI_TalonSRX turretMtr;

    private boolean m_trackingIsEnabled;
    private boolean m_isInverting;
    private double m_angle;
    private double m_targetAngle;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
     * Constructs a new ShooterSys.
     * 
     * ShooterSys contains the shooter motor.
     * 
     * This subsystem contains methods for setting the shooter power and stopping it.
     */
    public TurretSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        limelight = new Limelight();

        limelight.getStream();

        turretMtr = new WPI_TalonSRX(7);
        turretMtr.setSelectedSensorPosition(0);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        m_trackingIsEnabled = true;
        m_isInverting = false;
        m_angle = 0;
        m_targetAngle = 0;
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        
        m_angle = turretMtr.getSelectedSensorPosition() / Constants.Encoder.countsPerDegree;

        if(m_angle > 185) {
            if(limelight.getdegRotationToTarget() < -5) {
                m_targetAngle = -180;
                m_isInverting = true;
                m_trackingIsEnabled = false;
            }
            else if(limelight.getdegRotationToTarget() < 0) {
                setAngle(180);
            }
            else {
                track();
            }
        }
        else if(m_angle < -185) {
            if(limelight.getdegRotationToTarget() > 5) {
                m_targetAngle = 180;
                m_isInverting = true;
                m_trackingIsEnabled = false;
            }
            else if(limelight.getdegRotationToTarget() > 0) {
                setAngle(-180);
            }
            else {
                track();
            }
        }
        else {
            track();
        }

        // if(m_isInverting) {
        //     if(((m_targetAngle > 0 && m_angle > 0) || (m_targetAngle < 0 && m_angle < 0)) && limelight.getIsTargetFound()) {
        //         m_isInverting = false;
        //         m_targetAngle = 0;
        //         m_trackingIsEnabled = true;
        //     }
        //     else {
        //         setAngle(m_targetAngle);
        //     }
        // }

        if(limelight.getIsTargetFound()) {
            m_isInverting = false;
        }

        SmartDashboard.putNumber("turret angle", m_angle);
        SmartDashboard.putBoolean("isInverting", m_isInverting);
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    public void track() {
        if(m_trackingIsEnabled) {
            turretMtr.set(limelight.getdegRotationToTarget() * Constants.KP.turret);
        }
    }

    public void setAngle(double target) {
        if(limelight.getIsTargetFound()) {
            double power = ((m_angle - target) * Constants.KP.turret);
            if(power > 0.5) {
                power = 0.5;
            }
            else if(power < -0.5) {
                power = -0.5;
            }
            turretMtr.set(power);
        }
    }

    public void setLED(boolean on) {
        if(!on) {
            limelight.setLEDMode(LedMode.kforceOff);
        }
        else {
            limelight.setLEDMode(LedMode.kforceOn);
        }
    }

    public boolean isTargetFound() {
        return limelight.getIsTargetFound();
    }

    public double getX() {
        return limelight.getdegRotationToTarget();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
}

