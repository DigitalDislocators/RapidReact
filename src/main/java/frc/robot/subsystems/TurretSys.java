// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import oi.limelightvision.limelight.frc.Limelight;
import oi.limelightvision.limelight.frc.ControlMode.LedMode;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class TurretSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private Limelight limelight;
    private WPI_TalonSRX turretMtr;

    private boolean m_trackingIsEnabled;
    private boolean m_isTurning;
    private double m_angle;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
     * Constructs a new ShooterSys.
     * 
     * ShooterSys contains the shooter motor.
     * 
     * This subsystem contains methods for setting the shooter power and stopping it.
     */
    public TurretSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        limelight = new Limelight();

        limelight.getStream();

        turretMtr = new WPI_TalonSRX(7);
        turretMtr.setSelectedSensorPosition(0);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        m_trackingIsEnabled = true;
        m_isTurning = false;
        m_angle = 0;
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        
        m_angle = turretMtr.getSelectedSensorPosition() / Constants.Encoder.countsPerDegree;

        if(m_angle > 180) {
            if(limelight.getdegRotationToTarget() > 5) {
                setAngle(-180, false);
            } 
            else if(limelight.getdegRotationToTarget() < 0) {
                setAngle(180, true);
            }
            else {
                track();
            }
        }
        else if(m_angle < -180) {
            if(limelight.getdegRotationToTarget() > 5) {
                setAngle(180, false);
            }
            else if(limelight.getdegRotationToTarget() > 0) {
                setAngle(-180, true);
            }
            else {
                track();
            }
        }
        else {
            track();
        }

        // if(m_isInverting) {
        //     if(((m_targetAngle > 0 && m_angle > 0) || (m_targetAngle < 0 && m_angle < 0)) && limelight.getIsTargetFound()) {
        //         m_isInverting = false;
        //         m_targetAngle = 0;
        //         m_trackingIsEnabled = true;
        //     }
        //     else {
        //         setAngle(m_targetAngle);
        //     }
        // }

        SmartDashboard.putNumber("turret angle", m_angle);
        SmartDashboard.putBoolean("isTurning", m_isTurning);
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    public void track() {
        // if(m_trackingIsEnabled && !m_isTurning) {
        //     turretMtr.set(limelight.getdegRotationToTarget() * Constants.KP.turret);
        // }
    }

    public void setAngle(double target, boolean trackingEnabled) {
        m_isTurning = false;
        m_trackingIsEnabled = trackingEnabled;
        if(trackingEnabled && limelight.getIsTargetFound()) {
            m_trackingIsEnabled = true;
        }
        if(!m_trackingIsEnabled) {
            if(limelight.getIsTargetFound()) {
                m_trackingIsEnabled = true;
            }
            double power = ((m_angle - target) * Constants.KP.turret);
            if(power > 0.5) {
                power = 0.5;
            }
            else if(power < -0.5) {
                power = -0.5;
            }
            turretMtr.set(power);
        }
        if(m_angle < target + 10 && m_angle > target - 10) {
            m_trackingIsEnabled = true;
        }
    }

    public void control(double power) {
        if(power > 0.1 || power < -0.1 && m_angle <= 180 && m_angle >= -180) {
            m_isTurning = true;
            turretMtr.set(power);
        }
        else {
            m_isTurning = false;
            if((!limelight.getIsTargetFound() || !m_trackingIsEnabled) || (m_angle <= 180 && m_angle >= -180)) {
                turretMtr.stopMotor();
            }
        }
    }

    public boolean trackingIsEnabled() {
        return m_trackingIsEnabled;
    }
    public void setTrackingIsEnabled(boolean trackingIsEnabled) {
        m_trackingIsEnabled = trackingIsEnabled;
    }

    public void setLED(boolean on) {
        if(!on) {
            limelight.setLEDMode(LedMode.kforceOff);
        }
        else {
            limelight.setLEDMode(LedMode.kforceOn);
        }
    }

    public void zero() {
        turretMtr.setSelectedSensorPosition(0);
    }

    public boolean isTargetFound() {
        return limelight.getIsTargetFound();
    }

    public double getX() {
        return limelight.getdegRotationToTarget();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
}

