// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
// import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANSparkMax;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class ShooterSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax shooterMtr;
    private SparkMaxPIDController pidController;
    private double targetVelocity;
    private double error = 0;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
     * Constructs a new ShooterSys.
     * 
     * ShooterSys contains the shooter motor.
     * 
     * This subsystem contains methods for setting the shooter power and stopping it.
     */
    public ShooterSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        shooterMtr = new CANSparkMax(6, MotorType.kBrushless);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        pidController = shooterMtr.getPIDController();

        pidController.setP(Constants.PID.shooterP);
        pidController.setD(Constants.PID.shooterD);
        pidController.setFF(Constants.PID.shooterFF);
        pidController.setOutputRange(-0.5, 1.0);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

        // SmartDashboard.putNumber("shooter percent", shooterMtr.getEncoder().getVelocity() / Constants.Power.shooterMaxRPM);
        // SmartDashboard.putNumber("shooter target", shooterMtr.get());
        // SmartDashboard.putNumber("target velocity", targetVelocity);
        SmartDashboard.putNumber("shooter error", error);
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void set(double power) {
        targetVelocity = (power + error) * Constants.Power.shooterMaxRPM;

        shooterMtr.set(power + error);
    }

    public double get() {
        return shooterMtr.get();
    }

    public void stop() {
        targetVelocity = 0.0;
        shooterMtr.stopMotor();
    }

    public boolean isAtSpeed() {
        return shooterMtr.getEncoder().getVelocity() < targetVelocity + 25 && shooterMtr.getEncoder().getVelocity() > targetVelocity - 25;
    }

    private boolean upReleased = true;
    private boolean downReleased = true;

    public void errorControl(boolean up, boolean down) {
        if(up && upReleased) {
            error += 0.75;
            upReleased = false;
        }
        else if (!up) {
            upReleased = true;
        }

        if(down && downReleased) {
            error -= 0.75;
            downReleased = false;
        }
        else if (!down) {
            downReleased = true;
        }
    }
}

