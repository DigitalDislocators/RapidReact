// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;

import java.util.Map;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANSparkMax;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

public class ShooterSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax shooterMtr;
    private SparkMaxPIDController pidController;
    private double targetVelocity;
    private double error = 0;

    private Timer m_timer;
    
    private NetworkTableEntry sb_shooterPercent;
    private NetworkTableEntry sb_shooterTarget;
    private NetworkTableEntry sb_shooterError;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
     * Constructs a new ShooterSys.
     * 
     * ShooterSys contains the shooter motor.
     * 
     * This subsystem contains methods for setting the shooter power and stopping it.
     */
    public ShooterSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        shooterMtr = new CANSparkMax(6, MotorType.kBrushless);
        shooterMtr.setInverted(false);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        pidController = shooterMtr.getPIDController();
        pidController.setP(Constants.PID.shooterP);
        pidController.setD(Constants.PID.shooterD);
        pidController.setFF(Constants.PID.shooterFF);
        pidController.setOutputRange(-0.5, 1.0);

        sb_shooterPercent = Shuffleboard.getTab("DOOFENSHMIRTZ").add("Shooter Percent", 0)
            .withWidget(BuiltInWidgets.kDial)
            .withSize(3, 3)
            .withPosition(14, 0)
            .getEntry();
        sb_shooterTarget = Shuffleboard.getTab("DOOFENSHMIRTZ").add("Shooter Target", 0)
            .withWidget(BuiltInWidgets.kDial)
            .withSize(3, 3)
            .withPosition(17, 0)
            .getEntry();
        sb_shooterError = Shuffleboard.getTab("DOOFENSHMIRTZ").add("Shooter Error", 0)
            .withWidget(BuiltInWidgets.kNumberBar)
            .withProperties(Map.of("Min", -6, "Max", 6))
            .withSize(4, 2)
            .withPosition(16, 5)
            .getEntry();

        m_timer = new Timer();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        sb_shooterPercent.setDouble(shooterMtr.getEncoder().getVelocity() / Constants.Power.shooterMaxRPM * 100);
        sb_shooterTarget.setDouble(shooterMtr.get() * 100);
        sb_shooterError.setDouble(error * 100);

        // If shooter is going for a high goal shot, start the timer
        // Otherwise, reset the timer
        if(shooterMtr.get() > Constants.Power.lowGoal && m_timer.get() == 0) {
            m_timer.start();
        }
        else if (shooterMtr.get() <= Constants.Power.lowGoal) {
            m_timer.stop();
            m_timer.reset();
        }

        if(!DriverStation.isTeleop() || DriverStation.isDisabled()) {
            error = 0;
        }
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void set(double power) {
        // Making sure that power can't be set to more than 100%
        if(power == 0) {
            targetVelocity = (power) * Constants.Power.shooterMaxRPM;
            shooterMtr.set(power);
        }
        else if(power + error <= 1.0) {
            targetVelocity = (power + error) * Constants.Power.shooterMaxRPM;
            shooterMtr.set(power + error);
        }
        else {
            targetVelocity = Constants.Power.shooterMaxRPM;
            shooterMtr.set(1.0);
        }

    }

    public double get() {
        return shooterMtr.get();
    }

    public void stop() {
        targetVelocity = 0.0;
        shooterMtr.stopMotor();
    }

    public boolean isAtSpeed() {
        // If shooter never reaches target velocity (most likely battery voltage issue), it will say it has after the max spin up time
        // That way, the shooter won't just sit almost at speed and not fire
        return (shooterMtr.getEncoder().getVelocity() < targetVelocity + 50 && shooterMtr.getEncoder().getVelocity() > targetVelocity - 50) || m_timer.get() > Constants.Power.maxSpinUpTime;
    }

    /**
     * For Third Thursday demo
     * 
     * @param y y-value of desired joystick
     * @param run shooter will spin up only if true
     */
    public void joystickControl(double y, boolean run) {
        if(run) {
            if(shooterMtr.get() == 0) {
                shooterMtr.set(0.7);
            }
            else if(shooterMtr.get() < 0.5) {
                shooterMtr.set(0.5);
            }
            else if(shooterMtr.get() > 0.9) {
                shooterMtr.set(0.9);
            }
            else {
                if(Math.abs(y) > 0.25)
                shooterMtr.set(shooterMtr.get() + y * 0.0025);
            }
        }
        else {
            shooterMtr.stopMotor();
        }
    }

    public void errorControl(double value) {
        error += value * 0.01;
    }
}

